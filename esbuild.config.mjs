import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";
import path from "path";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const nodeModulesPath = path.join(__dirname, 'node_modules');

const banner =
`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
`;

const prod = (process.argv[2] === 'production');

// Path to onnxruntime-web browser bundle (version 1.14.0 to match @xenova/transformers)
const onnxWebBrowserBundle = path.join(nodeModulesPath, 'onnxruntime-web', 'dist', 'ort.min.js');

// CDN path for WASM files - MUST match the bundled onnxruntime-web version (1.14.0)
const WASM_CDN_PATH = 'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/';

// Plugin to intercept onnxruntime imports and inject WASM path configuration
// This ensures wasmPaths is set BEFORE any code uses the ort module
const onnxConfigPlugin = {
	name: 'onnx-config',
	setup(build) {
		// Intercept both onnxruntime-node and onnxruntime-web
		build.onResolve({ filter: /^onnxruntime-(node|web)$/ }, (args) => {
			return {
				path: args.path,
				namespace: 'onnx-configured'
			};
		});

		// Return a wrapper module that configures WASM paths at load time
		build.onLoad({ filter: /.*/, namespace: 'onnx-configured' }, () => {
			return {
				contents: `
					// Import the actual onnxruntime-web browser bundle
					const ort = require(${JSON.stringify(onnxWebBrowserBundle)});

					// Configure WASM paths IMMEDIATELY at module load time
					// This must happen before any inference session is created
					if (ort.env && ort.env.wasm) {
						ort.env.wasm.wasmPaths = ${JSON.stringify(WASM_CDN_PATH)};
						ort.env.wasm.numThreads = 1;
						ort.env.wasm.proxy = false;
						console.log('[ONNX Config] wasmPaths set to:', ort.env.wasm.wasmPaths);
					}

					// Re-export everything
					module.exports = ort;
				`,
				loader: 'js',
				resolveDir: nodeModulesPath
			};
		});
	}
};

// Plugin to replace 'sharp' with a stub module
// sharp is only needed for image processing pipelines, not text embeddings
// @xenova/transformers tries to load it but we don't use image features
const sharpShimPlugin = {
	name: 'sharp-shim',
	setup(build) {
		// Intercept requires for sharp
		build.onResolve({ filter: /^sharp$/ }, args => {
			return {
				path: args.path,
				namespace: 'sharp-shim'
			};
		});

		// Return a stub module that satisfies sharp's interface enough to not crash
		build.onLoad({ filter: /.*/, namespace: 'sharp-shim' }, () => {
			return {
				contents: `
					// Stub for sharp - we don't use image pipelines, only text embeddings
					// This provides a chainable no-op interface
					const sharpStub = function(input) {
						const instance = {
							resize: () => instance,
							extend: () => instance,
							extract: () => instance,
							trim: () => instance,
							rotate: () => instance,
							flip: () => instance,
							flop: () => instance,
							sharpen: () => instance,
							blur: () => instance,
							flatten: () => instance,
							gamma: () => instance,
							negate: () => instance,
							normalise: () => instance,
							normalize: () => instance,
							clahe: () => instance,
							convolve: () => instance,
							threshold: () => instance,
							linear: () => instance,
							recomb: () => instance,
							modulate: () => instance,
							tint: () => instance,
							greyscale: () => instance,
							grayscale: () => instance,
							toColourspace: () => instance,
							toColorspace: () => instance,
							removeAlpha: () => instance,
							ensureAlpha: () => instance,
							extractChannel: () => instance,
							joinChannel: () => instance,
							bandbool: () => instance,
							composite: () => instance,
							toFormat: () => instance,
							jpeg: () => instance,
							png: () => instance,
							webp: () => instance,
							gif: () => instance,
							tiff: () => instance,
							avif: () => instance,
							heif: () => instance,
							raw: () => instance,
							tile: () => instance,
							clone: () => instance,
							stats: () => Promise.resolve({}),
							metadata: () => Promise.resolve({ width: 0, height: 0, channels: 3 }),
							toBuffer: () => Promise.resolve(Buffer.from([])),
							toFile: () => Promise.resolve({}),
						};
						return instance;
					};

					// Static methods
					sharpStub.cache = () => {};
					sharpStub.concurrency = () => 1;
					sharpStub.counters = () => ({});
					sharpStub.simd = () => false;
					sharpStub.format = {};
					sharpStub.versions = {};

					module.exports = sharpStub;
					module.exports.default = sharpStub;
				`,
				loader: 'js'
			};
		});
	}
};

const context = await esbuild.context({
	banner: {
		js: banner,
	},
	entryPoints: ['main.ts'],
	bundle: true,
	plugins: [onnxConfigPlugin, sharpShimPlugin],
	external: [
		'obsidian',
		'electron',
		'@codemirror/autocomplete',
		'@codemirror/collab',
		'@codemirror/commands',
		'@codemirror/language',
		'@codemirror/lint',
		'@codemirror/search',
		'@codemirror/state',
		'@codemirror/view',
		'@lezer/common',
		'@lezer/highlight',
		'@lezer/lr',
		...builtins],
	// Use neutral platform for Obsidian (hybrid browser/node environment)
	platform: 'neutral',
	// Ensure main fields are resolved correctly for browser-compatible packages
	mainFields: ['browser', 'module', 'main'],
	format: 'cjs',
	target: 'es2020',
	logLevel: "info",
	sourcemap: prod ? false : 'inline',
	treeShaking: true,
	outfile: 'main.js',
	// Provide a valid import.meta.url for @xenova/transformers
	// The library uses this to determine its cache path, but we override it anyway
	define: {
		'import.meta.url': JSON.stringify('file:///transformers-cache/'),
	},
});

if (prod) {
	await context.rebuild();
	process.exit(0);
} else {
	await context.watch();
}
